# WritingAI - Portfolio

**AI와 함께 완성하는 창작의 즐거움, Companion Writer**

AI와 사용자가 번갈아가며 소설을 써나가는 인터랙티브 글쓰기 플랫폼입니다. 창작의 문턱을 낮추고, 일관성 있는 서사를 유지할 수 있도록 돕는 다양한 기능들을 제공합니다.

---

## 1. 프로젝트 개요

- **프로젝트 명**: WritingAI
- **개발 기간**: 2025.11.11 ~ 2026.01.06 (약 8주)
- **주요 목표**:
  - AI와의 실시간 협업을 통한 소설 창작 환경 구축
  - 시놉시스 및 설정집을 통한 서사 일관성 유지
  - 안전한 사용자 인증 및 개인 프로젝트 관리 시스템 구현

---

## 2. 주요 기능

### ✍️ 협력 글쓰기 (Cooperative Writing)
- 사용자가 한 단락을 작성하면 AI가 문맥을 분석해 다음 단락을 생성합니다.
- 사용자와 AI가 번갈아 가며 이야기를 만들어가는 턴제 방식을 채택했습니다.

### 📚 프로젝트 및 컨텍스트 관리
- **시놉시스**: 전체 줄거리를 기록하여 AI가 이야기의 방향성을 잃지 않도록 합니다.
- **설정집(Lorebook)**: 인물, 장소, 아이템 등의 정보를 체계적으로 관리하고 AI 프롬프트에 동적으로 삽입합니다.
- **프로젝트 관리**: 여러 개의 창작 프로젝트를 개별적으로 생성하고 관리할 수 있습니다.

### 🎭 장르 맞춤형 AI 스타일
- 판타지, 로맨스, 미스터리 등 7가지 장르별 특화된 프롬프트 엔지니어링을 통해 장르에 적합한 문체와 분위기를 제공합니다.

### 🔐 보안 및 사용자 인증
- Google OAuth 2.0 및 자체 이메일 로그인을 지원합니다.
- Access/Refresh Token 기반의 이중 인증 시스템과 HttpOnly 쿠키를 사용하여 보안성을 높였습니다.

---

## 3. 기술 스택 및 개발 환경

### Frontend
- **Framework**: React 19, TypeScript
- **Styling**: Tailwind CSS, Shadcn/UI
- **State Management**: Zustand, TanStack Query (v5)
- **Routing**: React Router 7
- **Form Management**: React Hook Form, Zod

### Backend
- **Server**: Express.js 5, TypeScript
- **Database**: MySQL/MariaDB, TypeORM 0.3
- **AI Integration**: OpenAI API (GPT-4o-mini)
- **Authentication**: JWT (JSON Web Token), bcrypt, Google Auth Library

## 4. OpenAI API 통합 및 프롬프트 엔지니어링

이 프로젝트의 핵심인 AI 협력 글쓰기 기능을 위해 OpenAI API를 전략적으로 활용했습니다.

### 🤖 모델 및 인터페이스 선정 이유
- **모델: GPT-4o-mini**: 소설의 문맥을 충분히 파악하면서도 응답 속도가 빠르고 비용 효율성이 뛰어난 `gpt-4o-mini`를 주 모델로 채택했습니다.
- **인터페이스: Chat Completions API (v4)**: 당시 최신이었던 Responses API(v5) 대신 기존의 Chat Completions API를 유지했습니다. 이는 소설 쓰기의 특성상 **이전 대화 기록(messages 배열)을 직관적으로 누적 관리**하는 것이 대화 맥락 유지에 더 유리하고 안정적이라는 판단 때문이었습니다.

### 🏗️ 구현 방식: 다층적 컨텍스트 구축 (Context Building)
단순한 질문-답변 형식을 넘어, 풍부한 서사를 위해 다음과 같은 정보를 동적으로 결합하여 프롬프트를 구성합니다.
1.  **System Prompt**: 시놉시스와 설정집을 참조하여 고정된 페르소나 부여
2.  **Narrative Context**: 최근 5개 단락의 내용을 포함하여 직전 사건과의 연결성 강화
3.  **World-Building (Lorebook)**: 현재 장면과 관련된 태그가 달린 설정(인물, 장소)을 선택적으로 주입하여 정보의 밀도 조절

### 🎭 장르별 페르소나 설계
각 장르의 고유한 분위기를 살리기 위해 영문 시스템 프롬프트를 상세히 설계했습니다 (내부적으로는 한국어로 응답).
- **판타지**: 풍부한 묘사와 마법 체계의 논리성 강조
- **스릴러**: 빠른 호흡의 문체와 심리적 압박감 형성
- **로맨스**: 감정의 미묘한 변화와 인물 간의 케미스트리 집중

### 🔧 트러블슈팅: 서사의 '급발진' 및 문체 이질감 해결
- **문제**: 초기 테스트 시 AI가 한 단락 만에 이야기의 결말을 지어버리거나(급발진), 사용자의 문체와 지나치게 이질적인 문어체를 사용하는 문제가 있었습니다.
- **해결**:
  - **Temperature 조절**: 창의성과 논리성의 균형을 위해 `temperature`를 0.8로 미세 조정했습니다.
  - **인스트럭션 강화**: "결말을 서두르지 말고 현재 상황에 집중하라"는 지침과 "현대적인 구어체 중심의 서사"를 강조하는 제약 조건을 시스템 프롬프트에 추가했습니다.
  - **맥락 제한**: 전체 단락이 아닌 최근 5개 단락으로 참조 범위를 제한하여 현재 장면에 집중하도록 유도했습니다.

### 📈 주요 성과 및 학습 포인트
- **성과**: 장르별 특화 프롬프트를 통해 사용자가 별도의 지시 없이도 장르에 어울리는 완성도 높은 문장을 얻을 수 있게 되었습니다. 
- **학습 포인트**: LLM이 가진 지식을 활용하는 것만큼이나, **우리가 제공하는 데이터(시놉시스, 설정집)를 어떻게 구조화하여 전달하느냐**가 결과물의 품질을 결정짓는 핵심임을 깨달았습니다.

---

## 5. 구현 방식 및 기술 선정 이유

### [Backend] 비동기 데이터베이스 연동 및 레이어드 아키텍처
- **TypeORM 선정 이유**: TypeScript와의 강력한 호환성 및 객체 지향적인 데이터 접근 방식을 선호하여 선정했습니다. Entity와 Data Mapper 패턴을 활용해 비즈니스 로직과 데이터 로직을 분리했습니다.
- **레이어드 아키텍처**: `Routes -> Controllers -> Services -> Entities`로 이어지는 레이어를 구축하여 코드의 유지보수성과 테스트 용이성을 확보했습니다.

### [Frontend] 서버 상태와 클라이언트 상태의 분리
- **TanStack Query (React Query)**: API 요청, 캐싱, 로딩 상태 처리를 서버 상태로 정의하고 TanStack Query로 관리하여 데이터 동기화 문제를 효율적으로 해결했습니다.
- **Zustand**: 로그인 정보와 같은 전역 클라이언트 상태를 가볍고 직관적으로 관리하기 위해 사용했습니다. Redux보다 보일러플레이트가 적어 생산성을 높일 수 있었습니다.

### [UX/UI] 사용자 경험 최적화
- **Debounced Save**: 시놉시스와 설정집 수정 시 사용자의 입력을 실시간으로 감지하되, 2초간 멈췄을 때만 서버에 저장하는 디바운싱 기법을 적용하여 서버 부하를 줄이고 매끄러운 타이핑 경험을 제공했습니다.
- **Flex-based Layout**: 헤더와 푸터를 고정하고 본문만 스크롤되는 레이아웃을 Flexbox로 구현하여 모달 창 오픈 시 발생할 수 있는 스크롤 방해 문제를 근본적으로 해결했습니다.

---

## 5. 트러블슈팅

### 1) TypeORM `synchronize: true` 데이터 유실 문제
- **문제**: 개발 초기 `synchronize: true` 옵션 사용으로 인해 서버 재시작 시 특정 컬럼(Lorebook)이 null로 초기화되는 현상이 발생했습니다.
- **해결**: 운영 환경과 유사한 안정성을 확보하기 위해 `synchronize: false`로 전환하고, `TypeORM Migration` 시스템을 도입하여 데이터베이스 스키마 변경 이력을 코드로 관리하도록 개선했습니다.

### 2) 인증 체크 시 불필요한 401 에러 로그
- **문제**: 비로그인 사용자가 홈에 접속할 때마다 `verify-user` API가 401을 반환하여 콘솔에 불필요한 에러 로그가 남았습니다.
- **해결**: 인증 확인 API가 세션이 없을 때 401 대신 **200 OK**와 함께 `authenticated: false` 플래그를 반환하도록 설계 변경하여 브라우저 수준의 강제 에러 로그를 방지하고 정상적인 흐름으로 처리했습니다.

### 3) 이중 토큰 시스템의 무한 루프 발생
- **문제**: Refresh Token 만료 시 `/refresh` 요청이 다시 401을 반환하며 응답 인터셉터가 무한히 재시도를 시도하는 오류가 있었습니다.
- **해결**: Axios 인터셉터 내부에서 갱신 요청 URL을 체크하여 예외 처리를 추가함으로써 무한 호출을 차단하고 자연스러운 로그아웃 처리가 되도록 구현했습니다.

---

## 6. 주요 성과

- **안정적인 AI 텍스트 생성**: 최근 5개 단락과 시놉시스, 설정집을 결합한 컨텍스트 빌딩 로직을 통해 서사의 일관성을 80% 이상(체감) 유지하는 데 성공했습니다.
- **보안 강화**: HttpOnly 쿠키와 리프레시 토큰을 활용해 XSS 공격에 대비한 토큰 저장 방식을 확립했습니다.
- **성능 개선**: `React Hook Form` 활용 및 `useState` 최적화를 통해 폼 리렌더링 시간을 기존 대비 약 50% 단축했습니다.

---

## 7. 회고 및 학습 포인트

- **커스텀 훅을 통한 로직 캡슐화**: `useAuth`, `useStoryContext` 등 비즈니스 로직을 커스텀 훅으로 분리하는 과정에서 React의 선언적 프로그래밍과 재사용성의 중요성을 깊이 체감했습니다.
- **보안과 편의성 사이의 균형**: 사용자 경험을 해치지 않으면서도 보안을 강화하기 위해 'Silent Refresh'와 같은 기술을 직접 구현하며 웹 인증 시스템에 대한 깊은 이해를 얻었습니다.
- **기록의 가치**: 8주간의 개발 로그를 꼼꼼히 작성한 덕분에, 프로젝트가 복잡해졌을 때 과거의 결정 이유를 쉽게 추적하고 이번 포트폴리오를 체계적으로 작성할 수 있었습니다.
